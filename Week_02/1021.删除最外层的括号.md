# 1021.删除最外层的括号

> 对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。
>
> 示例 1：
> ```
> 输入："(()())(())"
> 输出："()()()"
> 解释：
> 输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，
> 删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。
>```
> 示例 2：
> ```
> 输入："(()())(())(()(()))"
> 输出："()()()()(())"
> 解释：
> 输入字符串为 "(()())(())(()(()))"，原语化分解得到 "(()())" + "(())" + "(()(()))"，
> 删除每个部分中的最外层括号后得到 "()()" + "()" + "()(())" = "()()()()(())"。
>```
> 示例 3：
> ```
> 输入："()()"
> 输出：""
> 解释：
> 输入字符串为 "()()"，原语化分解得到 "()" + "()"，
> 删除每个部分中的最外层括号后得到 "" + "" = ""。
>```

## 解法一：栈

一看到括号，第一个想到的数据结构就是栈啦

### 解法

遍历字符串，有两种情况
1. 遇到 `(` ，发现栈长度大于 0，说明不是最外层的括号，加入结果。然后压入栈。
2. 遇到 `)` ，发现栈长度大于 1，说明不是最外层的括号，加入结果。然后弹出栈。

``` python
class Solution:
    def removeOuterParentheses(self, S: str) -> str:
        stack = []
        res = ""
        for c in S:
            if c == '(':
                if len(stack) > 0:
                    res += c
                stack.append(c)
            else:
                if len(stack) > 1:
                    res += c
                stack.pop()
        return res
```

### 复杂度分析
- 时间复杂度：O(n)，n 为字符串`S`的长度
- 空间复杂度：O(n)，n 为栈开辟的空间，输出结果的空间不算

## 解法二：未匹配括号数

### 解法

解法一的栈开着其实挺浪费的，我们可以用一个数字来表示未匹配的括号数 `l`。

遍历字符串，有两种情况
1. 遇到 `(` ，发现`l`大于 0，说明不是最外层的括号，加入结果。`l` + 1。
2. 遇到 `)` ，发现`l`大于 1，说明不是最外层的括号，加入结果。`l` - 1。

``` python
class Solution:
    def removeOuterParentheses(self, S: str) -> str:
        l, res = 0, ""
        for c in S:
            if c == '(':
                if l > 0:
                    res += c
                l += 1
            else:
                if l > 1:
                    res += c
                l -= 1
        return res
```

### 复杂度分析
- 时间复杂度：O(n)，n 为字符串`S`的长度
- 空间复杂度：O(1)，输出结果的空间不算