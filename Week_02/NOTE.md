# 学习笔记
## 哈希表

### 原理：
将值按照一定的哈希算法算出一个值，放在数组对应的位置(可能这个值就是index，也可能要取模)。

### 哈希碰撞：

不同的值按照哈希算法算出来的数字，可能是一样的，这种现象就叫做"哈希碰撞"。

如何解决这种现象带来的问题
- 要有个好的哈希算法，尽量减少哈希碰撞
- 在数组的每个值中，再拉出一串值，可以用链表，也可以用树。
- 扩容，增大 size，分布肯定就更加散了

### java 中的应用
#### Map(最常用 HashMap)
- 使用数组 + 链表(红黑树) 的数据结构
- size 永远是 2 的倍数，因为 HashMap 使用的哈希算法，在 size 是 2 的倍数可以很好地减少哈希碰撞的概率。
    - 哈希算法： hashCode & (hashMap.length-1)
    - 算法很有趣，算出来的数刚好不会超过容量，扩容的时候，碰撞的值大概率会被分散
- 减少哈希碰撞的方案还有扩容，当 size 达到容量的一定比例(负载因子，默认 0.75)之后，就会乘以 2 地扩容
- 当哈希碰撞造成链表太长(8 个)的话，会转成红黑树(jdk8 之后)

#### Set(最常用 HashSet)
- HashSet 其实就是个 HashMap，只是 value 都是一个固定值
- 其实这个固定值有点浪费，不过也就浪费一个 Object 的内存吧，还行

## 树

- 拥有链表、数组的优点，通常意义来说，增删改查的时间复杂度是 O(logn)。
- 二叉搜索树：比较常见，拥有 left、right 左右子树，左子树所有节点都小于根节点，右子树所有节点都大于根节点。
- 算法通常用递归，写起来会简洁很多。
    - 前中后序遍历
    - 直径
    - 高度
- 链表是特殊的树(相当于一叉树)

## 堆

- 可以快速找到一堆数中的最大值(大顶堆)或者最小值(小顶堆)
- 常见的堆是二叉堆，由完全二叉树实现(数组)
    - 查找顶值，O(1)
    - 插入：O(logn), heapifyUp
    - 删除：O(logn), heapifyDown
- 常见算法：
    - top K
    - 优先队列

## 图
- 图的构成：顶点、边
    - 点：
        - 度：入度、出度(拥有多少条指向它的边)
        - 点与点之间：是否连通
    - 边：
        - 有向(有箭头)、无向(无箭头)
        - 权重(边长)
- 向权分类
    - 无向无权
    - 有向无权
    - 无向有权
    - 有向有权
- 存储：
    - 邻接矩阵：用二维数组存。适用于稠密图。
    - 邻接表：用链表存，顶点会被存多次。适用于稀疏图。

- 常见算法：(记得 visited)
    - DFS
    - BFS