# 50. Pow(x, n)
实现 pow(x, n) ，即计算 x 的 n 次幂函数。

示例 1:
```
输入: 2.00000, 10
输出: 1024.00000
```

示例 2:
```
输入: 2.10000, 3
输出: 9.26100
```

示例 3:
```
输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
```
说明:
```
-100.0 < x < 100.0
n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。
```

## 解法一：暴力求解
- 暴力求解会超时


## 解法二：二分迭代法
### 解法
- n 是偶数：`x^n = x^(n/2) * x^(n/2)`
- n 是奇数：`x^n = x^(n/2) * x^(n/2) * n`
- 上面的公式可以看出，每次都可以把 n 对半折，logn 会快很多

**java**
```java
class Solution {
    public double myPow(double x, int n) {
        int tempN = n;
        double res = 1;
        while (tempN != 0) {
            // 奇数，最后一位是 1。如果用 tempN % 2，在 -1 的时候是 0 ~ 非常蛋疼
            if ((tempN & 1) == 1) res *= x;
            x *= x;
            tempN /= 2;
        }
        return n < 0? 1/res: res;
    }
}
```

**python**
- 注意 `python` 的取模在负数/整除的时候，跟 `java` 不同。
- python 往负无穷靠，java 往 0 靠。

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        res = 1; old_n = n
        while n != 0:
            if n % 2 == 1: res *= x
            x *= x
            if n >= 0: n //= 2
            # python 的取模在负数的时候跟 java 不同
            else: n = -(-n // 2)
        return res if old_n >= 0 else 1 / res
```

### 复杂度
- 时间复杂度：O(logn)，每次对半折，跟二分类似
- 空间复杂度: O(1)

